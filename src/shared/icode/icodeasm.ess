.include "icode.inc"
.include "error.inc"
.include "misc.inc"
.include "symtab.inc"
.include "scanner.inc"

; 13661 heap
; code $0810

.export _checkIcodeBounds
.export _extractSymtabNode
.export _freeIcode
.export _getCurrentIcodeLocation
.export _getNextTokenFromIcode
.export _gotoIcodePosition
.export _initIcodeCache
.export _insertLineMarker
.export _makeIcode
.export _putSymtabNodeToIcode
.export _putTokenToIcode
.export _resetIcodePosition

.import _abortTranslation, _allocChunk, _cachedIcodeHdr, _cachedIcodeHdrChunkNum
.import _cachedIcodeData, _cachedIcodeDataChunkNum, _codeSegmentSize
.import _currentLineNumber, _Error, _errorCount, _freeChunk
.import _mcLineMarker
.import _retrieveChunk, _storeChunk, _symbolStrings
.import popax, pushax
.importzp ptr1, ptr2, ptr3

.bss

size: .res 2

extractpNode: .res 2
extractChunkNum: .res 2
extractHdrChunkNum: .res 2

freeChunkNum: .res 2
freeHdrChunkNum: .res 2

getCode: .res 1
getNextHdrChunkNum: .res 2
getNextpNode: .res 2
getNextpToken: .res 2
pString: .res 2
symtabNode: .res .sizeof(SYMTABNODE)

gotoHdrChunkNum: .res 2
position: .res 2

initChunkNum: .res 2
initHdrChunkNum: .res 2

lastCode: .res 1
insertHdrChunkNum: .res 2
pos: .res 2

loadDataChunkNum: .res 2

loadHdrChunkNum: .res 2

makeChunkNum: .res 2

pullHdrChunkNum: .res 2
data: .res 2
length: .res 2
toCopy: .res 1

putHdrChunkNum: .res 2

putpNode: .res 2
putChunkNum: .res 2

putTokenCode: .res 1
putTokenChunkNum: .res 2

.code

; void checkIcodeBounds(CHUNKNUM hdrChunkNum, int size)
.proc _checkIcodeBounds
    ; Save the second parameter
    sta size
    stx size + 1
    ; Retrieve the first parameter
    jsr popax

    ; Load the header from cache
    jsr _loadHeaderCache

    ; Add global position to size
    clc
    lda size
    adc _cachedIcodeHdr + ICODE::posGlobal
    sta size
    lda size + 1
    adc _cachedIcodeHdr + ICODE::posGlobal + 1
    sta size + 1

    ; Compare it to codeSegmentSize
    lda size + 1
    cmp _codeSegmentSize + 1
    bcc @Done
    lda size
    cmp _codeSegmentSize
    bcc @Done

    ; Segment overflow
    lda #errCodeSegmentOverflow
    jsr _Error
    lda #abortCodeSegmentOverflow
    jsr _abortTranslation

@Done:
    rts
.endproc

; char extractSymtabNode(CHUNKNUM hdrChunkNum, SYMTABNODE *pNode)
.proc _extractSymtabNode
    ; Store the pNode parameter
    sta extractpNode
    stx extractpNode + 1
    ; Store the hdrChunkNum parameter
    jsr popax
    sta extractHdrChunkNum
    stx extractHdrChunkNum + 1

    ; Call _pullDataFromIcode
    ; First parameter
    lda extractHdrChunkNum
    ldx extractHdrChunkNum + 1
    jsr pushax
    ; Second parameter
    lda #<extractChunkNum
    ldx #>extractChunkNum
    jsr pushax
    lda #2
    ldx #0
    jsr _pullDataFromIcode

    ; Call retrieveChunk
    ; First parameter
    lda extractChunkNum
    ldx extractChunkNum + 1
    jsr pushax
    ; Second parameter
    lda extractpNode
    ldx extractpNode + 1
    jmp _retrieveChunk

.endproc

; void flushIcodeCache()
.proc _flushIcodeCache
    ; Check if _cachedIcodeHdrChunkNum is non-zero
    lda _cachedIcodeHdrChunkNum
    ora _cachedIcodeHdrChunkNum + 1
    beq @CheckDataChunkNum      ; _cachedIcodeHdrChunkNum is zero
@StoreHdr:
    ; first parameter to _storeChunk
    lda _cachedIcodeHdrChunkNum
    ldx _cachedIcodeHdrChunkNum + 1
    jsr pushax
    ; second parameter to _storeChunk
    lda #<_cachedIcodeHdr
    ldx #>_cachedIcodeHdr
    jsr _storeChunk
    ; Set the header chunknum to zero
    lda #0
    sta _cachedIcodeHdrChunkNum
    sta _cachedIcodeHdrChunkNum + 1

@CheckDataChunkNum:
    ; Check if _cachedIcodeDataChunkNum is non-zero
    lda _cachedIcodeDataChunkNum
    ora _cachedIcodeDataChunkNum + 1
    beq @Done
@StoreData:
    ; first parameter to _storeChunk
    lda _cachedIcodeDataChunkNum
    ldx _cachedIcodeDataChunkNum + 1
    jsr pushax
    ; second parameter to _storeChunk
    lda #<_cachedIcodeData
    ldx #>_cachedIcodeData
    jsr _storeChunk
    ; Set the header chunknum to zero
    lda #0
    sta _cachedIcodeDataChunkNum
    sta _cachedIcodeDataChunkNum + 1

@Done:
    rts

.endproc

; void freeIcode(CHUNKNUM chunkNum)
.proc _freeIcode
    ; Store the parameter
    sta freeChunkNum
    sta freeHdrChunkNum
    stx freeChunkNum + 1
    stx freeHdrChunkNum + 1

    jsr _flushIcodeCache

    ; Call loadHeaderCache
    lda freeChunkNum
    ldx freeChunkNum + 1
    jsr _loadHeaderCache

    ; Store the first chunkNum
    lda _cachedIcodeHdr + ICODE::firstChunkNum
    sta freeChunkNum
    lda _cachedIcodeHdr + ICODE::firstChunkNum + 1
    sta freeChunkNum + 1

@Loop:
    ; While chunkNum != 0
    lda freeChunkNum
    ora freeChunkNum + 1
    beq @Done

    ; Retrieve the data chunk
    ; first parameter for retrieveChunk
    lda freeChunkNum
    ldx freeChunkNum + 1
    jsr pushax
    ; second parameter for retrieveChunk
    lda #<_cachedIcodeData
    ldx #>_cachedIcodeData
    jsr _retrieveChunk
    cmp #0
    beq @Done

    ; Free the chunk
    lda freeChunkNum
    ldx freeChunkNum + 1
    jsr _freeChunk

    ; Next chunkNum
    lda _cachedIcodeData + ICODE_CHUNK::nextChunk
    sta freeChunkNum
    lda _cachedIcodeData + ICODE_CHUNK::nextChunk + 1
    sta freeChunkNum + 1

    jmp @Loop

@Done:
    ; Free the header chunk
    lda freeHdrChunkNum
    ldx freeHdrChunkNum + 1
    jsr _freeChunk

    ; Clear the cached chunk numbers
    lda #0
    sta _cachedIcodeHdrChunkNum
    sta _cachedIcodeHdrChunkNum + 1
    sta _cachedIcodeDataChunkNum
    sta _cachedIcodeDataChunkNum + 1

    rts

.endproc

; unsigned getCurrentIcodeLocation(CHUNKNUM chunkNum)
.proc _getCurrentIcodeLocation
    ; Retrieve the cached header block
    ; .A and .X already contain the chunkNum
    jsr _loadHeaderCache

    ; Return the global position in .A and .X
    lda _cachedIcodeHdr + ICODE::posGlobal
    ldx _cachedIcodeHdr + ICODE::posGlobal + 1
    rts
.endproc

.proc _getNextTokenFromIcode
    ; Save the third parameter
    sta getNextpNode
    stx getNextpNode + 1
    ; Save the second parameter
    jsr popax
    sta getNextpToken
    stx getNextpToken + 1
    ; Save the first parameter
    jsr popax
    sta getNextHdrChunkNum
    stx getNextHdrChunkNum + 1

    ; Loop to process any line markers and extract the next token code.

@LookForLineMarker:
    ; Read the first token
    lda getNextHdrChunkNum
    ldx getNextHdrChunkNum + 1
    jsr pushax
    lda #<getCode
    ldx #>getCode
    jsr pushax
    lda #1
    ldx #0
    jsr _pullDataFromIcode
    lda getCode
    cmp _mcLineMarker
    bne @LookAtTokenCode
    ; Extract the line number
    lda getNextHdrChunkNum
    ldx getNextHdrChunkNum + 1
    jsr pushax
    lda #<_currentLineNumber
    ldx #>_currentLineNumber
    jsr pushax
    lda #2
    ldx #0
    jsr _pullDataFromIcode
    jmp @LookForLineMarker

@LookAtTokenCode:
    ; Look for tcNumber, tcIdentifier, or tcString (symbol table node)
    lda getCode
    cmp #tcNumber
    beq @HasSymbolTableNode
    cmp #tcIdentifier
    beq @HasSymbolTableNode
    cmp #tcString
    bne @HasSpecialToken

@HasSymbolTableNode:
    ; Extract a symbol table node

    lda getNextHdrChunkNum
    ldx getNextHdrChunkNum + 1
    jsr pushax
    lda #<symtabNode
    ldx #>symtabNode
    jsr _extractSymtabNode

    ; Clear the string

    lda getNextpToken
    sta ptr1
    lda getNextpToken + 1
    sta ptr1 + 1
    ; Add the structure offset for pToken->string
    clc
    lda ptr1
    adc #4
    sta ptr1
    sta pString
    lda ptr1 + 1
    adc #0
    sta ptr1 + 1
    sta pString + 1
    ; Loop to clear the string buffer
    ldy #TOKEN_STRING_LEN
    dey
    lda #0
@ClrLoop:
    sta (ptr1),y
    dey
    bpl @ClrLoop

    ; Retrieve the token name from the symbol table
    lda symtabNode + SYMTABNODE::nameChunkNum
    ldx symtabNode + SYMTABNODE::nameChunkNum + 1
    jsr pushax
    lda pString
    ldx pString + 1
    jsr _retrieveChunk

    ; If the caller provided a pointer to a symbol table node,
    ; copy the retrieved node into their buffer.
    lda getNextpNode
    ora getNextpNode + 1
    beq @Done

    ; Copy the retrieved node into the caller's buffer
    ; ptr1 is the caller's pNode buffer
    lda getNextpNode
    sta ptr1
    lda getNextpNode + 1
    sta ptr1 + 1
    ; ptr2 is the retrieved node buffer (the source)
    lda #<symtabNode
    sta ptr2
    lda #>symtabNode
    sta ptr2 + 1
    ldy #.sizeof(SYMTABNODE)
    dey
@CopyLoop:
    lda (ptr2),y
    sta (ptr1),y
    dey
    bpl @CopyLoop

    jmp @Done

@HasSpecialToken:
    ; Copy the string for this token into the token's string buffer

    ; ptr1 is the token's string buffer (the destination)
    lda getNextpToken
    sta ptr1
    lda getNextpToken + 1
    sta ptr1 + 1
    ; offset to the string buffer portion of the token
    clc
    lda ptr1
    adc #4
    sta ptr1
    lda ptr1 + 1
    adc #0
    sta ptr1 + 1

    ; ptr2 is the symbol string (the source of the copy)
    lda getCode
    adc getCode
    tay
    lda _symbolStrings,y
    sta ptr2
    iny
    lda _symbolStrings,y
    sta ptr2 + 1

    ; Copy the string, including the null terminator
    ldy #0
@TokenLoop:
    lda (ptr2),y
    sta (ptr1),y
    beq @Done
    iny
    jmp @TokenLoop

@Done:
    ; Store the token code in the pToken buffer
    lda getNextpToken
    sta ptr1
    lda getNextpToken + 1
    sta ptr1 + 1
    lda getCode
    ldy #0
    sta (ptr1),y
    rts

.endproc

; void gotoIcodePosition(CHUNKNUM hdrChunkNum, unsigned position)
.proc _gotoIcodePosition
    ; Store the second parameter
    sta position
    stx position + 1
    ; Store the first parameter
    jsr popax
    sta gotoHdrChunkNum
    stx gotoHdrChunkNum + 1

    ; Call loadHeaderCache
    lda gotoHdrChunkNum
    ldx gotoHdrChunkNum + 1
    jsr _loadHeaderCache

    ; Reset the icode position
    lda #0
    sta _cachedIcodeHdr + ICODE::posGlobal
    sta _cachedIcodeHdr + ICODE::posGlobal + 1
    sta _cachedIcodeHdr + ICODE::posChunk
    sta _cachedIcodeHdr + ICODE::posChunk + 1

    ; Copy the firstChunkNum to currentChunkNum
    lda _cachedIcodeHdr + ICODE::firstChunkNum
    sta _cachedIcodeHdr + ICODE::currentChunkNum
    lda _cachedIcodeHdr + ICODE::firstChunkNum + 1
    sta _cachedIcodeHdr + ICODE::currentChunkNum + 1

    ; Loop until we get to the position we want
@Loop:
    ; Retrieve the chunk
    lda _cachedIcodeHdr + ICODE::currentChunkNum
    ldx _cachedIcodeHdr + ICODE::currentChunkNum + 1
    jsr _loadDataCache

    ; If position < ICODE_CHUNK_LEN, this is the chunk we want
    lda position
    cmp #ICODE_CHUNK_LEN
    bcs @NextChunk      ; greater than or equal
    lda position + 1
    bne @NextChunk

    ; This is the chunk we want - set the icode header positions
    clc
    lda _cachedIcodeHdr + ICODE::posGlobal
    adc position
    sta _cachedIcodeHdr + ICODE::posGlobal
    lda _cachedIcodeHdr + ICODE::posGlobal + 1
    adc position + 1
    sta _cachedIcodeHdr + ICODE::posGlobal + 1
    ; set the chunk position
    lda position
    sta _cachedIcodeHdr + ICODE::posChunk
    lda position + 1
    sta _cachedIcodeHdr + ICODE::posChunk + 1
    jmp @Done

@NextChunk:
    ; Increment the global position
    clc
    lda position
    adc #ICODE_CHUNK_LEN
    sta position
    lda position + 1
    adc #0
    sta position + 1

    ; Decrement position
    sec
    lda position
    sbc #ICODE_CHUNK_LEN
    sta position
    lda position + 1
    sbc #0
    sta position + 1

    ; Set the next chunkNum
    lda _cachedIcodeData + ICODE_CHUNK::nextChunk
    sta _cachedIcodeHdr + ICODE::currentChunkNum
    lda _cachedIcodeData + ICODE_CHUNK::nextChunk + 1
    sta _cachedIcodeHdr + ICODE::currentChunkNum + 1

    jmp @Loop

@Done:
    rts

.endproc

; void initIcodeCache(void)
.proc _initIcodeCache
    lda #0
    sta _cachedIcodeHdrChunkNum
    sta _cachedIcodeHdrChunkNum + 1
    sta _cachedIcodeDataChunkNum
    sta _cachedIcodeDataChunkNum + 1
    rts
.endproc

; void initIcodeChunk(CHUNKNUM hdrChunkNum)
.proc _initIcodeChunk
    ; Store the parameter
    sta initHdrChunkNum
    stx initHdrChunkNum + 1

    jsr _flushIcodeCache

    ; Call loadHeaderCache
    lda initHdrChunkNum
    ldx initHdrChunkNum + 1
    jsr _loadHeaderCache

    ; Allocate a new chunk
    lda #<initChunkNum
    ldx #>initChunkNum
    jsr _allocChunk
    cmp #0
    bne @CheckFirstChunk
    ; Segment overflow (out of memory)
    lda #errCodeSegmentOverflow
    ldx #0
    jsr _Error
    lda #abortCodeSegmentOverflow
    ldx #0
    jsr _abortTranslation
    jmp @Done

@CheckFirstChunk:
    ; Is this the first chunk in the ICODE table?
    lda _cachedIcodeHdr + ICODE::firstChunkNum
    ora _cachedIcodeHdr + ICODE::firstChunkNum + 1
    bne @SetNextChunk
    ; First chunk in ICODE table
    lda initChunkNum
    sta _cachedIcodeHdr + ICODE::firstChunkNum
    lda initChunkNum + 1
    sta _cachedIcodeHdr + ICODE::firstChunkNum + 1
    jmp @SetupDataChunk

@SetNextChunk:
    ; Set the previous chunk's nextChunk to point to this new node

    ; Retrieve the current chunk
    ; First parameter to retrieveChunk
    lda _cachedIcodeHdr + ICODE::currentChunkNum
    ldx _cachedIcodeHdr + ICODE::currentChunkNum + 1
    jsr pushax
    ; Second parameter
    lda #<_cachedIcodeData
    ldx #>_cachedIcodeData
    jsr _retrieveChunk

    ; Set the next chunk number
    lda initChunkNum
    sta _cachedIcodeData + ICODE_CHUNK::nextChunk
    lda initChunkNum + 1
    sta _cachedIcodeData + ICODE_CHUNK::nextChunk + 1

    ; Store the chunk
    ; First parameter
    lda _cachedIcodeHdr + ICODE::currentChunkNum
    ldx _cachedIcodeHdr + ICODE::currentChunkNum + 1
    jsr pushax
    ; Second parameter
    lda #<_cachedIcodeData
    ldx #>_cachedIcodeData
    jsr _storeChunk
    cmp #0
    bne @SetupDataChunk

    ; Failed to store the chunk
    lda #errCodeSegmentOverflow
    ldx #0
    jsr _Error
    lda #abortCodeSegmentOverflow
    ldx #0
    jsr _abortTranslation
    jmp @Done

@SetupDataChunk:
    ; Set the new data chunk to 0's
    ldy #.sizeof(ICODE_CHUNK)
    lda #<_cachedIcodeData
    sta ptr1
    lda #>_cachedIcodeData
    sta ptr1 + 1
    lda #0
@Loop:
    sta (ptr1),y
    dey
    bne @Loop

    ; Set the header's currentChunkNum to the new chunkNum
    lda initChunkNum
    sta _cachedIcodeHdr + ICODE::currentChunkNum
    lda initChunkNum + 1
    sta _cachedIcodeHdr + ICODE::currentChunkNum + 1
    lda #0
    sta _cachedIcodeHdr + ICODE::posChunk
    sta _cachedIcodeHdr + ICODE::posChunk + 1

    ; Load the data cache with the new data chunk
    lda initChunkNum
    ldx initChunkNum + 1
    jsr _loadDataCache

@Done:
    rts

.endproc

; void insertLineMarker(CHUNKNUM hdrChunkNum)
.proc _insertLineMarker
    ; Save the parameter
    sta insertHdrChunkNum
    stx insertHdrChunkNum + 1

    ; If errorCount is non-zero, bail
    lda _errorCount
    ora _errorCount + 1
    bne @JmpDone

    ; Load the header from cache
    lda insertHdrChunkNum
    ldx insertHdrChunkNum + 1
    jsr _loadHeaderCache

    ; Remember the last appended token

    ; Are we at the beginning of the chunk already?
    lda _cachedIcodeHdr + ICODE::posChunk
    bne @BackUpPos
    ; Yes.  Are we also at the start of the icode?
    lda _cachedIcodeHdr + ICODE::posGlobal
    ora _cachedIcodeHdr + ICODE::posGlobal + 1
    beq @JmpDone  ; yes - can't back up any more

    ; We are at the start of the chunk already.
    ; We will need to load the previous chunk.
    lda _cachedIcodeHdr + ICODE::posGlobal
    sta pos
    lda _cachedIcodeHdr + ICODE::posGlobal + 1
    sta pos + 1
    ; Subtract 1 from the pos
    sec
    lda pos
    sbc #1
    sta pos
    lda pos + 1
    sbc #0
    sta pos
    ; Call gotoIcodePosition
    lda pos
    ldx pos + 1
    jsr pushax
    lda insertHdrChunkNum
    ldx insertHdrChunkNum + 1
    jsr _gotoIcodePosition
    jmp @GetLastToken

@JmpDone:
    jmp @Done

@BackUpPos:
    dec _cachedIcodeHdr + ICODE::posChunk
    sec
    lda _cachedIcodeHdr + ICODE::posGlobal
    sbc #1
    sta _cachedIcodeHdr + ICODE::posGlobal
    lda _cachedIcodeHdr + ICODE::posGlobal + 1
    sbc #0
    sta _cachedIcodeHdr + ICODE::posGlobal + 1

@GetLastToken:
    ; Load the data cache for the current chunk
    lda _cachedIcodeHdr + ICODE::currentChunkNum
    ldx _cachedIcodeHdr + ICODE::currentChunkNum + 1
    jsr _loadDataCache
    ; Calculate the address of the token code we need to read
    lda #<_cachedIcodeData
    sta ptr1
    lda #>_cachedIcodeData
    sta ptr1 + 1
    ; Add 2 to get to the data portion of the chunk
    clc
    lda ptr1
    adc #2
    sta ptr1
    lda ptr1 + 1
    adc #0
    sta ptr1 + 1
    ; Add the chunk offset
    clc
    lda ptr1
    adc _cachedIcodeHdr + ICODE::posChunk
    sta ptr1
    lda ptr1 + 1
    adc #0
    sta ptr1 + 1
    ; Get the last code
    ldy #0
    lda (ptr1),y
    sta lastCode

    ; Check icode bounds
    lda insertHdrChunkNum
    ldx insertHdrChunkNum + 1
    jsr pushax
    lda #3
    jsr _checkIcodeBounds

    ; Insert the line marker token
    lda _mcLineMarker
    sta pos
    lda insertHdrChunkNum
    ldx insertHdrChunkNum + 1
    jsr pushax
    lda #<pos
    ldx #>pos
    jsr pushax
    lda #1
    ldx #0
    jsr _putDataToIcode

    ; Insert the current line number
    lda insertHdrChunkNum
    ldx insertHdrChunkNum + 1
    jsr pushax
    lda #<_currentLineNumber
    ldx #>_currentLineNumber
    jsr pushax
    lda #2
    ldx #0
    jsr _putDataToIcode

    ; Re-append the last token code
    lda insertHdrChunkNum
    ldx insertHdrChunkNum + 1
    jsr pushax
    lda #<lastCode
    ldx #>lastCode
    jsr pushax
    lda #1
    ldx #0
    jsr _putDataToIcode

@Done:
    rts

.endproc

; void loadDataCache(CHUNKNUM chunkNum)
.proc _loadDataCache
    ; Store the chunkNum parameter
    sta loadDataChunkNum
    stx loadDataChunkNum + 1
    ; Compare _cachedIcodeDataChunkNum to chunkNum
    ; If they're the same value, nothing to do
    lda _cachedIcodeDataChunkNum
    cmp loadDataChunkNum
    bne @CheckChunkNumNonZero
    lda _cachedIcodeDataChunkNum + 1
    cmp loadDataChunkNum + 1
    beq @Done                   ; chunknum didn't change - nothing to do

@CheckChunkNumNonZero:
    ; See if _cachedIcodeDataChunkNum is non-zero
    ; If it is, store the chunk
    lda _cachedIcodeDataChunkNum
    ora _cachedIcodeDataChunkNum + 1
    beq @RetrieveChunk          ; it's zero - skip to retrieving

@StoreChunk:
    ; first parameter to storeChunk
    lda _cachedIcodeDataChunkNum
    ldx _cachedIcodeDataChunkNum + 1
    jsr pushax
    ; second parameter to storeChunk
    lda #<_cachedIcodeData
    ldx #>_cachedIcodeData
    jsr _storeChunk

@RetrieveChunk:
    ; first parameter to retrieveChunk
    lda loadDataChunkNum
    sta _cachedIcodeDataChunkNum
    ldx loadDataChunkNum + 1
    stx _cachedIcodeDataChunkNum + 1
    jsr pushax
    ; second parameter to retrieveChunk
    lda #<_cachedIcodeData
    ldx #>_cachedIcodeData
    jsr _retrieveChunk

@Done:
    rts

.endproc

.proc _loadHeaderCache
    ; Store the chunkNum parameter
    sta loadHdrChunkNum
    stx loadHdrChunkNum + 1
    ; Compare _cachedIcodeHdrChunkNum to chunkNum
    ; If they're the same value, nothing to do
    lda _cachedIcodeHdrChunkNum
    cmp loadHdrChunkNum
    bne @CheckChunkNumNonZero
    lda _cachedIcodeHdrChunkNum + 1
    cmp loadHdrChunkNum + 1
    beq @Done                   ; chunknum didn't change - nothing to do

@CheckChunkNumNonZero:
    ; See if _cachedIcodeHdrChunkNum is non-zero
    ; If it is, store the chunk
    lda _cachedIcodeHdrChunkNum
    ora _cachedIcodeHdrChunkNum + 1
    beq @RetrieveChunk          ; it's zero - skip to retrieving

@StoreChunk:
    ; first parameter to storeChunk
    lda _cachedIcodeHdrChunkNum
    ldx _cachedIcodeHdrChunkNum + 1
    jsr pushax
    ; second parameter to storeChunk
    lda #<_cachedIcodeHdr
    ldx #>_cachedIcodeHdr
    jsr _storeChunk

@RetrieveChunk:
    ; first parameter to retrieveChunk
    lda loadHdrChunkNum
    sta _cachedIcodeHdrChunkNum
    ldx loadHdrChunkNum + 1
    stx _cachedIcodeHdrChunkNum + 1
    jsr pushax
    ; second parameter to retrieveChunk
    lda #<_cachedIcodeHdr
    ldx #>_cachedIcodeHdr
    jsr _retrieveChunk

@Done:
    rts

.endproc

.proc _makeIcode
    ; Store the chunkNum pointer
    sta makeChunkNum
    stx makeChunkNum + 1

    ; Flush the header cache so we can reuse it
    jsr _flushIcodeCache

    ; Clear the header values
    lda #0
    sta _cachedIcodeHdrChunkNum + ICODE::currentChunkNum
    sta _cachedIcodeHdrChunkNum + ICODE::currentChunkNum + 1
    sta _cachedIcodeHdrChunkNum + ICODE::firstChunkNum
    sta _cachedIcodeHdrChunkNum + ICODE::firstChunkNum + 1
    sta _cachedIcodeHdrChunkNum + ICODE::posGlobal
    sta _cachedIcodeHdrChunkNum + ICODE::posGlobal + 1
    sta _cachedIcodeHdrChunkNum + ICODE::posChunk
    sta _cachedIcodeHdrChunkNum + ICODE::posChunk + 1
    
    ; Allocate a new chunk for the header
    lda makeChunkNum
    ldx makeChunkNum + 1
    jsr _allocChunk

    ; Call _storeChunk(chunkNum, ICODE *)
    lda #<_cachedIcodeHdrChunkNum
    ldx #>_cachedIcodeHdrChunkNum
    jsr pushax

    lda makeChunkNum
    ldx makeChunkNum + 1

    jmp _storeChunk

.endproc

; void pullDataFromIcode(CHUNKNUM chunkNum, unsigned char *data, unsigned length)
.proc _pullDataFromIcode
    ; Store the third parameter
    sta length
    stx length + 1
    ; Store the second parameter
    jsr popax
    sta data
    stx data + 1
    ; Store the first parameter
    jsr popax
    sta pullHdrChunkNum
    stx pullHdrChunkNum + 1

    ; Call loadHeaderCache
    jsr _loadHeaderCache

    ; If currentChunkNum is non-zero, load the data cache
    lda _cachedIcodeHdr + ICODE::currentChunkNum
    ora _cachedIcodeHdr + ICODE::currentChunkNum + 1
    bne @LoadDataCache

    ; currentChunkNum is zero.  If firstChunkNum is also zero, bail out.
    lda _cachedIcodeHdr + ICODE::firstChunkNum
    ora _cachedIcodeHdr + ICODE::firstChunkNum + 1
    beq @JmpDone

    ; Set currentChunkNum from firstChunkNum
    lda _cachedIcodeHdr + ICODE::firstChunkNum
    sta _cachedIcodeHdr + ICODE::currentChunkNum
    lda _cachedIcodeHdr + ICODE::firstChunkNum + 1
    sta _cachedIcodeHdr + ICODE::currentChunkNum + 1

@LoadDataCache:
    ; Load the data cache with the current chunk from the ICODE
    lda _cachedIcodeHdr + ICODE::currentChunkNum
    ldx _cachedIcodeHdr + ICODE::currentChunkNum + 1
    jsr _loadDataCache
    jmp @BlockLoop

@JmpDone:
    jmp @Done

    ; Loop until length is zero
@BlockLoop:
    lda length
    ora length + 1
    beq @JmpDone

    ; Calculate # of bytes to copy and put in toCopy
    ; if (length > ICODE_CHUNK_LEN - hdr.posChunk)
    ;    toCopy = ICODE_CHUNK_LEN - hdr.posChunk
    ; else
    ;    toCopy = length
    lda #ICODE_CHUNK_LEN
    sec
    sbc _cachedIcodeHdr + ICODE::posChunk
    sta toCopy              ; Assume we're copying ICODE_CHUNK_LEN - posChunk
    lda length + 1
    bne @CopyData           ; HB of length is non-zero.  length is definitely bigger.
    lda toCopy              ; if length > toCopy
    cmp length
    bcc @CopyData           ; LB of length > ICODE_CHUNK_LEN - posChunk
    ; length <= ICODE_CHUNK_LEN - posChunk
    lda length
    sta toCopy

@CopyData:
    ; ptr1 is the caller's data buffer
    lda data
    sta ptr1
    lda data + 1
    sta ptr1 + 1
    ; ptr2 is the source data buffer
    lda #<_cachedIcodeData
    sta ptr2
    lda #>_cachedIcodeData
    sta ptr2 + 1
    ; Add struct offset of 2 to ptr2
    clc
    lda ptr2
    adc #2
    sta ptr2
    lda ptr2 + 1
    adc #0
    sta ptr2 + 1
    ; Add hdr.posChunk to ptr2
    clc
    lda ptr2
    adc _cachedIcodeHdr + ICODE::posChunk
    sta ptr2
    lda ptr2 + 1
    adc #0
    sta ptr2 + 1
    ldy toCopy
    beq @Done
    dey
@CopyLoop:
    lda (ptr2),y
    sta (ptr1),y
    dey
    bpl @CopyLoop

    ; Move hdr.posChunk forward by toCopy
    clc
    lda _cachedIcodeHdr + ICODE::posChunk
    adc toCopy
    sta _cachedIcodeHdr + ICODE::posChunk
    lda _cachedIcodeHdr + ICODE::posChunk + 1
    adc #0
    sta _cachedIcodeHdr + ICODE::posChunk + 1

    ; Move hdr.posGlobal forward by toCopy
    clc
    lda _cachedIcodeHdr + ICODE::posGlobal
    adc toCopy
    sta _cachedIcodeHdr + ICODE::posGlobal
    lda _cachedIcodeHdr + ICODE::posGlobal + 1
    adc #0
    sta _cachedIcodeHdr + ICODE::posGlobal + 1

    ; Move data forward by toCopy
    clc
    lda data
    adc toCopy
    sta data
    lda data + 1
    adc #0
    sta data + 1

    ; Decrease length by toCopy
    sec
    lda length
    sbc toCopy
    sta length
    lda length + 1
    sbc #0
    sta length + 1

    ; If length is zero, we're done
    lda length
    ora length + 1
    beq @Done

    ; If there's no nextChunk, we're done
    lda _cachedIcodeData + ICODE_CHUNK::nextChunk
    ora _cachedIcodeData + ICODE_CHUNK::nextChunk + 1
    beq @Done

    ; Set hdr.posChunk to 0
    lda #0
    sta _cachedIcodeHdr + ICODE::posChunk
    sta _cachedIcodeHdr + ICODE::posChunk + 1

    ; Set hdr.currentChunk to data's nextChunk
    lda _cachedIcodeData + ICODE_CHUNK::nextChunk
    sta _cachedIcodeHdr + ICODE::currentChunkNum
    lda _cachedIcodeData + ICODE_CHUNK::nextChunk + 1
    sta _cachedIcodeHdr + ICODE::currentChunkNum + 1

    jmp @LoadDataCache

@Done:
    rts

.endproc

; void putDataToIcode(CHUNKNUM chunkNum, unsigned char *data, unsigned length)
.proc _putDataToIcode
    ; Store the third parameter
    sta length
    stx length + 1
    ; Store the second parameter
    jsr popax
    sta data
    stx data + 1
    ; Store the first parameter
    jsr popax
    sta putHdrChunkNum
    stx putHdrChunkNum + 1

    ; Call loadHeaderCache
    jsr _loadHeaderCache

    ; Check if hdr.firstChunkNum is zero
    lda _cachedIcodeHdr + ICODE::firstChunkNum
    ora _cachedIcodeHdr + ICODE::firstChunkNum + 1
    bne @LoadFirstChunk

    ; hdr.firstChunkNum is zero.  Initialize a new chunk
    lda putHdrChunkNum
    ldx putHdrChunkNum + 1
    jsr _initIcodeChunk
    jmp @BlockLoop

@LoadFirstChunk:
    ; If currentChunkNum is non-zero, load the data cache
    lda _cachedIcodeHdr + ICODE::currentChunkNum
    ora _cachedIcodeHdr + ICODE::currentChunkNum + 1
    bne @LoadDataCache

    ; Set currentChunkNum from firstChunkNum
    lda _cachedIcodeHdr + ICODE::firstChunkNum
    sta _cachedIcodeHdr + ICODE::currentChunkNum
    lda _cachedIcodeHdr + ICODE::firstChunkNum + 1
    sta _cachedIcodeHdr + ICODE::currentChunkNum + 1

@LoadDataCache:
    ; Load the data cache with the current chunk from the ICODE
    lda _cachedIcodeHdr + ICODE::currentChunkNum
    ldx _cachedIcodeHdr + ICODE::currentChunkNum + 1
    jsr _loadDataCache
    jmp @BlockLoop

@JmpDone:
    jmp @Done

    ; Loop until length is zero
@BlockLoop:
    lda length
    ora length + 1
    beq @JmpDone

    ; Calculate # of bytes to copy and put in toCopy
    ; if (length > ICODE_CHUNK_LEN - hdr.posChunk)
    ;    toCopy = ICODE_CHUNK_LEN - hdr.posChunk
    ; else
    ;    toCopy = length
    lda #ICODE_CHUNK_LEN
    sec
    sbc _cachedIcodeHdr + ICODE::posChunk
    sta toCopy              ; Assume we're copying ICODE_CHUNK_LEN - posChunk
    lda length + 1
    bne @CopyData           ; HB of length is non-zero.  length is definitely bigger.
    lda toCopy              ; if length > toCopy
    cmp length
    bcc @CopyData           ; LB of length > ICODE_CHUNK_LEN - posChunk
    ; length <= ICODE_CHUNK_LEN - posChunk
    lda length
    sta toCopy

@CopyData:
    ; ptr1 is the caller's data buffer
    lda data
    sta ptr1
    lda data + 1
    sta ptr1 + 1
    ; ptr2 is the destination data buffer
    lda #<_cachedIcodeData
    sta ptr2
    lda #>_cachedIcodeData
    sta ptr2 + 1
    ; Add struct offset of 2 to ptr2
    clc
    lda ptr2
    adc #2
    sta ptr2
    lda ptr2 + 1
    adc #0
    sta ptr2 + 1
    ; Add hdr.posChunk to ptr2
    clc
    lda ptr2
    adc _cachedIcodeHdr + ICODE::posChunk
    sta ptr2
    lda ptr2 + 1
    adc #0
    sta ptr2 + 1
    ldy toCopy
    beq @InitNextChunk
    dey
@CopyLoop:
    lda (ptr1),y
    sta (ptr2),y
    dey
    bpl @CopyLoop

    ; Move hdr.posChunk forward by toCopy
    clc
    lda _cachedIcodeHdr + ICODE::posChunk
    adc toCopy
    sta _cachedIcodeHdr + ICODE::posChunk
    lda _cachedIcodeHdr + ICODE::posChunk + 1
    adc #0
    sta _cachedIcodeHdr + ICODE::posChunk + 1

    ; Move hdr.posGlobal forward by toCopy
    clc
    lda _cachedIcodeHdr + ICODE::posGlobal
    adc toCopy
    sta _cachedIcodeHdr + ICODE::posGlobal
    lda _cachedIcodeHdr + ICODE::posGlobal + 1
    adc #0
    sta _cachedIcodeHdr + ICODE::posGlobal + 1

    ; Move data forward by toCopy
    clc
    lda data
    adc toCopy
    sta data
    lda data + 1
    adc #0
    sta data + 1

    ; Decrease length by toCopy
    sec
    lda length
    sbc toCopy
    sta length
    lda length + 1
    sbc #0
    sta length + 1

    ; If length is zero, we're done
    lda length
    ora length + 1
    beq @Done

@InitNextChunk:
    lda putHdrChunkNum
    ldx putHdrChunkNum + 1
    jsr _initIcodeChunk

    jmp @BlockLoop

@Done:
    rts

.endproc

; void putSymtabNodeToIcode(CHUNKNUM chunkNum, SYMTABNODE *pNode)
.proc _putSymtabNodeToIcode
    ; Store the pNode parameter
    sta putpNode
    stx putpNode + 1
    ; Store the chunkNum parameter
    jsr popax
    sta putChunkNum
    stx putChunkNum + 1

    ; Do nothing if _errorCount is non-zero
    lda _errorCount
    ora _errorCount + 1
    bne @Done

    ; check Icode bounds
    ; first parameter to _checkIcodeBounds
    lda putChunkNum
    ldx putChunkNum + 1
    jsr pushax
    ; second parameter to _checkIcodeBounds
    lda #2
    ldx #0
    jsr _checkIcodeBounds

    ; write node to icode
    ; first parameter to _putSymtaNodeToIcode
    lda putChunkNum
    ldx putChunkNum + 1
    jsr pushax
    ; second parameter to _putSymtabNodeToIcode
    lda putpNode
    ldx putpNode + 1
    jsr pushax
    ; third parameter to _putSymtabNodeToIcode
    lda #2
    ldx #0
    jsr _putDataToIcode

@Done:
    rts

.endproc

; void putTokenToIcode(CHUNKNUM chunkNum, TTokenCode tc)
.proc _putTokenToIcode
    ; Store the code parameter
    sta putTokenCode
    ; Store the chunkNum parameter
    jsr popax
    sta putTokenChunkNum
    stx putTokenChunkNum + 1

    ; Do nothing if _errorCount is non-zero
    lda _errorCount
    ora _errorCount + 1
    bne @Done

    ; check Icode bounds
    ; first parameter to _checkIcodeBounds
    lda putTokenChunkNum
    ldx putTokenChunkNum + 1
    jsr pushax
    ; second parameter to _checkIcodeBounds
    lda #1
    ldx #0
    jsr _checkIcodeBounds

    ; write token to icode
    ; first parameter to _putDataToIcode
    lda putTokenChunkNum
    ldx putTokenChunkNum + 1
    jsr pushax
    ; second parameter to _putDataToIcode
    lda #<putTokenCode
    ldx #>putTokenCode
    jsr pushax
    ; third parameter to _putDataToIcode
    lda #1
    ldx #0
    jsr _putDataToIcode

@Done:
    rts

.endproc

; void resetIcodePosition(CHUNKNUM chunkNum)
.proc _resetIcodePosition
    ; chunknum is already in .A and .X
    jsr _loadHeaderCache

    lda #0
    sta _cachedIcodeHdr + ICODE::currentChunkNum
    sta _cachedIcodeHdr + ICODE::posGlobal
    sta _cachedIcodeHdr + ICODE::posChunk

    rts
.endproc
